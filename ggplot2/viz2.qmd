---
title: "Elements of Data Science <br> SDS 322E"
author: "H. Sherry Zhang <br> Department of Statistics and Data Sciences <br> The University of Texas at Austin <br>  <br> Fall 2025"
format: 
  revealjs:
    scrollable: true
    slide-number: true
    show-slide-number: all
    aspectratio: 169
    smaller: true
    theme: serif
    preview-links: auto
    pdf-separate-fragments: true
include-in-header:
  - text: |
      <style>
      .reveal .custom3070 > div.column:first-child {
        width: 30%;
      }
      .reveal .custom3070 div.column:not(:first-child) {
        width: 70%;
      }
      </style>
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center")
library(tidyverse)
library(patchwork)
library(gapminder)
library(nycflights13)
library(flipbookr) # remotes::install_github("kjhealy/flipbookr@quarto")
```

## Geometries/ Aethetics {.smaller}

Here is a list of common aesthetics, `aes()`: 
  
   <center>`x`, `y`, `group`, `color`, `fill`, `size`, `alpha`, `linetype` </center>

. . .

Here is a list of most common `geom_xxx()`: 
  
  <center>`geom_point()`, `geom_line()`, `geom_histogram()`, `geom_density()`, `geom_boxplot()`, `geom_text()`, `geom_label()`, `geom_smooth()`</center>

. . .

Here are more: 

  <center>`geom_abline()`, `geom_hline()`, `geom_vline()`, `geom_tile()`, `geom_raster()`, `geom_polygon()`, `geom_area()`, `geom_segment()`, `geom_curve()`, `geom_path()`, `geom_jitter()`, `geom_dotplot()`, `geom_violin()`, `geom_errorbar()`, `geom_errorbarh()`, `geom_crossbar()`, `geom_linerange()`, `geom_pointrange()`,  `geom_sf()`, `geom_map()`, `geom_text_repel()`, `geom_label_repel()`, `geom_tile()`, `geom_ribbon()`, `geom_segment()`, `geom_curve()`</center>

. . .

But - which one to use? 

## Which geom to use? {.smaller}

Unless you're instructed to make a xxx plot, you will need to decide which geom to use based on the type of data you have and the story you want to tell.

In a project, it is often not straightforward to know the exact plot you want and you tweak it until you're satisfied. (We will see what this means) trails and errors....

## [What's the issue with the plot on the left?]{.r-fit-text}

::::{.columns}

:::{.column}

```{r}
set.seed(123)
tibble(x = rnorm(10000), 
       y = rnorm(10000)) |> 
  ggplot(aes(x = x , y = y)) + 
  geom_point()
```
:::

:::{.column}
```{r}
set.seed(123)
tibble(x = rnorm(10000), 
       y = rnorm(10000)) |> 
  ggplot(aes(x = x , y = y)) + 
  geom_point(size = 0.1)
```
:::

::::

When plotting too many points, we may consider reduce the point size to avoid overplotting.

## A better example {.smaller}

```{r}
#| output-location: column
set.seed(123)
tibble(x = rnorm(10000), 
       y = rnorm(10000)) |> 
  ggplot(aes(x = x , y = y)) + 
  geom_point(size = 0.1)
```

Why is `size` specified outside `aes(...)`?

. . .


  
`aesthetic` specifies how a *variable* in the data is mapped to a visual property. Here, `color = "blue"` is a constant value to be applied to all lines, hence you want to specify it inside the `geom_xxx()`, but outside `aes(...)`. 

*Remember you can specify the `aes(...)` layer inside `ggplot()` and `geom_xxx()`.*

## [Plots the distribution of a continuous variable]{.r-fit-text}

Example: the monthly temperature of the JFK airport in New York City

```{r}
options(pillar.width = 80)
library(nycflights13)
(jfk_df <- weather |> 
    filter(origin == "JFK") |>
    mutate(month = as.factor(month)) |> 
    select(origin, year, month, day, temp))
```

## How about `geom_point()`? 

```{r}
jfk_df |> 
  ggplot(aes(x = month, y = temp)) + 
  geom_point()
```

 - `r emo::ji("sad")` the points are squashed together, we can't see the distribution
 - `r emo::ji("happy")` but it does allow us to see there is one particular point with the lowest temperature in May

## How about `geom_jitter()`?

As an alternative to `geom_point()`, `geom_jitter()` adds a small amount of random noise to the position of each point, which helps to spread out the points and make them more visible.

```{r}
jfk_df |> 
  ggplot(aes(x = month, y = temp, group = month)) + 
  geom_jitter(width = 0.2)
```

- `r emo::ji("sad")` the points are loosen up, but we can't see the distribution

## How about `geom_boxplot()`? 

```{r}
jfk_df |> 
  ggplot(aes(x = month, y = temp, group = month)) + 
  geom_boxplot()
```

 - `r emo::ji("sad")` now we can see the five number summary - better than all the points lining up in one line
 
## How about `geom_violin()`? 

```{r}
jfk_df |> 
  ggplot(aes(x = month, y = temp, group = month)) +
  geom_violin()
```

- `r emo::ji("happy")` now we can see the distribution and the long whisker in May signals the interesting low temperature in May. Sure...

## How about `geom_quasirandom()`? 

```{r}
jfk_df |> 
  ggplot(aes(x = month, y = temp, group = month)) + 
  ggbeeswarm::geom_quasirandom(size = 0.5)
```

- `r emo::ji("happy")` the long whisker in May signals the interesting low temperature in May
- `r emo::ji("happy")` Now we can see the distribution: most of the days in March is around 40F, but In November, the temperature is bi-modal: part of it clusters are around 40F and another around 50F. 

## [Why are distributions important? (1/4)]{.r-fit-text}

I have simulated three sets of observations (100 observations each), `dt`, and plot them using geom_boxplot(). 

Does the boxplot tell you anything about the distribution of the data?

```{r echo = FALSE}
set.seed(1234)
dt <- tibble(id = 1: 100, 
             x1 = 1: 100, 
             x2 = rnorm(100, 50, 30), 
             x3 = c(rnorm(50, 25, 10), rnorm(50, 70, 10))) |> 
  pivot_longer(names_to = "x", values_to = "value", cols = -id) |>
  mutate(x = parse_number(x)) |> 
  filter(between(value, 0, 99))
```

```{r}
dt |>  
  ggplot(aes(x = x, y = value, group = x)) + 
  geom_boxplot()
```

. . .

Is it so? 

## [Why are distributions important? (2/4)]{.r-fit-text}

```{r}
dt |> 
  ggplot(aes(x = x, y = value, group = x)) + 
  geom_violin()
```

## [Why are distributions important? (3/4)]{.r-fit-text}

```{r}
dt |> 
  ggplot(aes(x = x, y = value, group = x)) + 
  ggbeeswarm::geom_quasirandom(width = 0.3)
```

## [Why are distributions important? (4/4)]{.r-fit-text}

```{r}
dt |> 
  ggplot(aes(x = value, group = x, fill = as.factor(x))) + 
  geom_density() + 
  facet_wrap(vars(x), ncol = 1)
```

## `geom_hist()`

## [Which one is better: pie chart or bar chart?]{.r-fit-text} {.smaller}

```{r echo = FALSE}
data <- data.frame(
  group=LETTERS[1:5],
  value=c(13,7,9,21,2)
)

# Compute the position of labels
data <- data %>% 
  arrange(desc(group)) %>%
  mutate(prop = value / sum(data$value) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )

# Basic piechart
p1 <- ggplot(data, aes(x = "", y = prop, fill = group)) +
  geom_bar(stat = "identity", width = 1, color = "white") +
  coord_polar("y", start = 0) +
  theme_void() +
  theme(legend.position = "none") +
  geom_text(aes(y = ypos, label = group), color = "white", size = 6)

p2 <- ggplot(data, aes(x = group, y = prop, fill = group)) +
  geom_col()
p1 | p2
```

. . .

Pie chart is **never** a good idea, because it is hard to compare the size of the slices e.g. A vs. C

## More on `geom_bar()` and `geom_col()`

## Density with reduced alpha

## Sorting boxplot across mean value

```{r}
gapminder::gapminder |> 
  #filter(continent == "Americas") |> 
  ggplot(aes(x = lifeExp, group = country)) + 
  geom_density()
```

## race and age two categories: how to determine facet and bars depends on the interpretation

