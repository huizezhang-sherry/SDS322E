---
title: "Elements of Data Science <br> SDS 322E"
author: "H. Sherry Zhang <br> Department of Statistics and Data Sciences <br> The University of Texas at Austin <br>  <br> Fall 2025"
format: 
  revealjs:
    scrollable: true
    slide-number: true
    show-slide-number: all
    aspectratio: 169
    smaller: true
    theme: serif
    preview-links: auto
    pdf-separate-fragments: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center")
options(pillar.width = 70, pillar.print_max = 5, pillar.print_min = 5)
library(tidyverse)
library(nycflights13)
```

## Learning objective

We will learn the five most basic `dplyr` verbs to wrangle data, including:

- `filter()`: filter rows by a predicate
- `mutate()`: create or modify variables
- `group_by()`: group data by one or more variables
- `summarize()`: summarize data by groups
- `arrange()`: sort data by one or more variables

These are the fundamentals for building up more complex data wrangling...

## [Some history]{.smaller}

```{r echo = FALSE}
cran_raw <- cranlogs::cran_downloads(
  packages = c("tidyr", "dplyr", "plyr", "reshape", "reshape2"), 
  from = "2005-01-01", to = "2024-12-31") |> 
  as_tibble()

cran_df <- cran_raw |> 
  group_by(package, year = year(date)) |>
  summarize(count = sum(count), .groups = "drop")

cran_df |> 
  ggplot(aes(x = year, y = count/ 1000000, color = package)) +
  geom_point() + 
  geom_line() + 
  theme(legend.position = "bottom") +
  ylab("Count (in million)")
```


## {background-image="figures/dplyr-filter.png" background-size="90%"}


:::footer
Artwork by @allison_horst
:::

## `dplyr` syntax

<center>```DATA |> filter(PREDICATE)```</center>

```{r eval = FALSE}
# basic
flights |> filter(dep_delay > 120)

# by a single value
flights |> filter(month == 1)

# by multiple value
flights |> filter(month %in% c(1, 3))

# by negation
flights |> filter(month != 1)
flights |> filter(!month %in% c(1, 3))

# by multiple condition
flights |> filter(month == 1 & dep_delay > 120)
flights |> filter(month == 1, dep_delay > 120)
flights |> filter(month == 1 | dep_delay > 120)
```

## These predicates comes from how you compare vectors in R 

```{r}
1 == 1
1 == 2
1 != 2
```

. . .

```{r}
3 %in% c(1, 2)
!(3 %in% c(1, 2))
```

. . .

```{r}
(1 == 1) & (1 == 2) # TRUE and FALSE -> FALSE
(1 == 1) | (1 == 2) # TRUE or FALSE -> TRUE
```

## [Find all the entries with departure delay larger than 2 hours]{.r-fit-text}

```{r}
flights |> filter(dep_delay > 120)
```

## Find all the entries in January

```{r}
flights |> filter(month == 1)
```


## What goes wrong here?

```{r eval = FALSE}
flights |> filter(month = 1)
```

![](figures/dplyr-error.png)

. . .

```{r}
flights |> filter(month == 1)
```

## Your time 

```{r eval = FALSE}
usethis::create_from_github("SDS322E-2025FALL/0203-dplyr")
```

Read slides 4 and 5 to write the code answering the following questions:

1) Find the flights that depart from `JFK` 
2) Find the flights that depart from `JFK` in January
3) Find the flights that depart from `EWR` and `LGA` and not in January

You may start from:

```{r eval = FALSE}
flights |> filter(...)
```

## Solution

1) Find the flights that depart from `JFK` 

```{r eval = FALSE}
flights |> filter(origin == "JFK")
```

. . .

2) Find the flights that depart from `JFK` and `LGA` in January

```{r eval = FALSE}
flights |> filter(origin %in% c("JFK", "LGA"), month == 1)
# its also okay to write
flights |> filter(origin %in% c("JFK", "LGA") & month == 1)
```

. . .

3) Find the flights that not depart from `EWR` and `LGA` and not in January

```{r eval = FALSE}
flights |> filter(!origin %in% c("EWR", "LGA"), month != 1)
```

## {background-image="figures/dplyr-mutate.png" background-size="60%"}

:::footer
Artwork by @allison_horst
:::

## `mutate()` syntax 

<center>```DATA |> mutate(VARIABLE = EXPRESSION) ```</center>

If `VARIABLE` already exists, it modifies the column; otherwise, it will create a new one.

```{r}
flights |> mutate(gain = dep_delay - arr_delay)
```


## [You can put multiple mutations together, or separately]{.r-fit-text}

These two are identical: 

```{r echo = FALSE}
options(pillar.width= 50)
```


::::{.columns}

:::{.column}

```{r}
flights |> 
  mutate(gain = dep_delay - arr_delay, 
         speed = distance / (air_time / 60))
```

:::

:::{.column}

```{r}
flights |> 
  mutate(gain = dep_delay - arr_delay) |> 
  mutate(speed = distance / (air_time / 60))
```

:::

::::

## [We can also compare them properly :)]{.r-fit-text}

```{r}
v1 <- flights |> 
  mutate(gain = dep_delay - arr_delay, 
         speed = distance / (air_time / 60))

v2 <- flights |> 
  mutate(gain = dep_delay - arr_delay) |> 
  mutate(speed = distance / (air_time / 60))

identical(v1, v2)
```

## Something about design

By default, columns are mutated in the end of the data frame, what if you want to put them at position xxxx? How do I do something like this? 

```{r echo = FALSE}
flights |> 
  mutate(gain = dep_delay - arr_delay, .before = 1) |> 
  head()
```


. . .

Part of the reason `tidyverse` is neat is that it makes things easy. But define easy ...


. . .

You will *expect* for every main task, you don't need to do much for small tweaks.

## Your time

Read the documentation of `mutate()` and modify the following code to put the `gain` column:

```{r eval = FALSE}
flights |> 
  mutate(gain = dep_delay - arr_delay) 
```

* as the first column, 
* after the `day` variable, and 
* keep only the columns used to create the `gain` column

## Solution 

```{r eval = FALSE}
flights |> mutate(gain = dep_delay - arr_delay, .before = 1) 
flights |> mutate(gain = dep_delay - arr_delay, .after = day)
flights |> mutate(gain = dep_delay - arr_delay, .keep = "used")
```

Why these arguments have "." in front of everything?

. . .

:::{.fragment}

  * *Function developer* needs to accommodate the fact that users will do all sorts of things with their functions, e.g. you may name a column `after` for the number of mins after the scheduled time
  * If `after` is also an argument name inside `mutate()`, it will then be confusing whether you are referring to the column or the argument.
  * Prefixing the argument name with `.` avoids this problem -- **it's a good practice**.

I don't say you should prefix all your variables with `.`, but package developers should do that for good practice.

:::


# Sorry, Allison Horst doesn't have art illustration for  `group_by()` and `summarize()`


## `group_by()` and `summarize()`

<center>```DATA |> group_by(VARIABLEs) |> summarize(EXPRESSION)```</center>

Example:

```{r}
flights |> group_by(month)
```

The header tells you that the data is grouped by `month` and there are 12 groups (12 months).

## Example

::::{.columns}
:::{.column}

```{r}
flights |>
  group_by(month) |>
  summarize(avg_dep_delay = mean(dep_delay))
```
:::


:::{.column}
:::{.fragment}

I hope you remember:

```{r}
flights |>
  group_by(month) |>
  summarize(avg_dep_delay = 
              mean(dep_delay, na.rm = TRUE))
```
:::
:::

::::

## But notice `summarize()` and `summary()` are two different verbs

* `summarize()` is a dplyr verb to summarize groups in a way you specified
* `summary()` is a base R function to provide the 5 number summary (min, quantile, median, mean, max) for each variable in a data frame

```{r}
summary(flights$dep_delay)
summary(flights)
```



## [Of course, you can do multiple summaries]{.r-fit-text}

```{r}
flights |>
  group_by(month, origin) |>
  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE),
            avg_arr_delay = mean(arr_delay, na.rm = TRUE))
```

. . . 

But the following means summarize `avg_dep_delay` first, then summarize `avg_arr_delay` from the result of the first summary, which is not what we want:

```{r eval = FALSE}
flights |>
  group_by(month, origin) |>
  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE)) |> 
  summarize(avg_arr_delay = mean(arr_delay, na.rm = TRUE))
```

## Your time

Apply the `group_by()` + `summarize()` syntax to calculate the average flight distance for each of the three origins. Your results should look like this:

```{r echo = FALSE}
flights |> group_by(origin) |> summarize(distance = mean(distance, na.rm = TRUE))
```

. . .

Solution

```{r}
flights |> group_by(origin) |> summarize(distance = mean(distance, na.rm = TRUE))
```



## [Let me sneak in a new verb: `arrange()`]{.r-fit-text}

Sometimes, we may wish to have the result sorted by a variable, this can be done with `arrange()`:

::::{.columns}

:::{.column}

```{r echo = FALSE}
options(pillar.print_max = 10, pillar.print_min = 10)
```


```{r}
flights |>
  group_by(carrier) |>
  summarize(avg_dep_delay = 
              mean(arr_delay, na.rm = TRUE))
```

:::

:::{.column}
:::{.fragment}

```{r}
flights |>
  group_by(carrier) |>
  summarize(avg_dep_delay = 
              mean(arr_delay, na.rm = TRUE)) |> 
  arrange(avg_dep_delay)
```

:::
:::

::::

## [Let me sneak in a new verb: `arrange()`]{.r-fit-text}

Sort by decreasing order can be done with either `-` or `desc()`:

::::{.columns}

:::{.column}

```{r echo = FALSE}
options(pillar.print_max = 20, pillar.print_min = 20)
```


```{r}
flights |>
  group_by(carrier) |>
  summarize(avg_dep_delay = 
              mean(arr_delay, na.rm = TRUE)) |> 
  arrange(-avg_dep_delay)
```

:::

:::{.column}

```{r}
flights |>
  group_by(carrier) |>
  summarize(avg_dep_delay = 
              mean(arr_delay, na.rm = TRUE)) |> 
  arrange(desc(avg_dep_delay))
```

:::

::::


# Combine everything together: Decompose a problem into dplyr verbs

##

**Task: We want to sumamrize the proportion of flights with departure delay larger than 2 hours.**

. . .

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  

. . .

This sounds like a `mutate()` and we learn the "larger than 2 hrs" part in `filter()`

. . .

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") 
```

##

**Task: We want to summarize the proportion of flights with departure delay larger than 2 hours.**

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  
2. Then I need to count the number of observations for over and below 2h delay.

. . .

This sounds like `group_by()` and `summarize()`, but I want what's inside `summarise()` to be the count

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") |> 
  group_by(over_2h_delay) |>
  summarise(n = n())
```

## 

**Task: We want to summarize the proportion of flights with departure delay larger than 2 hours.**

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  
2. Then I need to count the number of observations for over and below 2h delay.
3. Then I need to calculate proportion based on `n`.

. . .

This sounds like `mutate()` again

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") |> 
  group_by(over_2h_delay) |>
  summarise(n = n()) |> 
  mutate(prop = n/ sum(n) * 100)
```

## Remark 1

```{r echo = FALSE}
options(pillar.print_max = 5, pillar.print_min = 5)
```

::::{.columns}

:::{.column width="45%"}
Can we look at those NAs? 

```{r}
flights |> filter(is.na(dep_delay))
```


There are records with no arrival and departure time - we will need to keep them in mind about this data.
:::

:::{.column width="53%"}

:::{.fragment}
Why can't you do 

<center>`filter(dep_delay == NA)`?</center>

This is not legit because comparing anything with `NA` gives an `NA` (rather than giving `FALSE`):

```{r}
1 == NA
2!= NA
```
:::
:::
::::

## Remark 2

`group_by(over_2h_delay) |> summarise(n = n())` can be simplified with a single command `dplyr::count(over_2h_delay)`.


::::{.columns}

:::{.column}
```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, 
         .keep = "used") |> 
  group_by(over_2h_delay) |>
  summarise(n = n()) |> 
  mutate(prop = n/ sum(n) * 100)
```

:::

:::{.column}
```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, 
         .keep = "used") |> 
  count(over_2h_delay) |> 
  mutate(prop = n/ sum(n) * 100)
```
:::

::::


## Your time

Can you reproduce the code we just walked through for the following task? 

<center>**Task: We want to summarize the proportion of flights with departure delay larger than 2 hours.**</center>

<br>

. . .

Here is the step breakdown if you need:

  1. I need label the rows as whether they are delay more than 2 hrs or not.  
  2. Then I need to count the number of observations for over and below 2h delay.
  3. Then I need to calculate proportion based on `n`.
