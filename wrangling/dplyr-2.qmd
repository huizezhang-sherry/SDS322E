---
title: "Elements of Data Science <br> SDS 322E"
author: "H. Sherry Zhang <br> Department of Statistics and Data Sciences <br> The University of Texas at Austin <br>  <br> Fall 2025"
format: 
  revealjs:
    scrollable: true
    slide-number: true
    show-slide-number: all
    aspectratio: 169
    smaller: true
    theme: serif
    preview-links: auto
    pdf-separate-fragments: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, fig.align = "center")
options(pillar.width = 70, pillar.print_max = 5, pillar.print_min = 5)
library(tidyverse)
library(nycflights13)
```

## {background-image="figures/dplyr-filter.png" background-size="90%"}


:::footer
Artwork by @allison_horst
:::

## `dplyr` syntax

<center>```DATA |> filter(PREDICATE)```</center>

```{r eval = FALSE}
# basic
flights |> filter(dep_delay > 120)

# by a single value
flights |> filter(month == 1)

# by multiple value
flights |> filter(month %in% c(1, 3))

# by negation
flights |> filter(month != 1)
flights |> filter(!month %in% c(1, 3))

# by multiple condition
flights |> filter(month == 1 & dep_delay > 120)
flights |> filter(month == 1, dep_delay > 120)
flights |> filter(month == 1 | dep_delay > 120)
```

## These predicates comes from how you compare vectors in R 

```{r}
1 == 1
1 == 2
1 != 2
```

. . .

```{r}
3 %in% c(1, 2)
!(3 %in% c(1, 2))
```

. . .

```{r}
(1 == 1) & (1 == 2) # TRUE and FALSE -> FALSE
(1 == 1) | (1 == 2) # TRUE or FALSE -> TRUE
```


## [Warm up: how many airport are there in NYC?]{.r-fit-text}

```{r}
flights$origin |> unique()
```

## [Find all the entries with departure delay larger than 2 hours]{.r-fit-text}

```{r}
flights |> filter(dep_delay > 120)
```

## Find all the entries in January

```{r}
flights |> filter(month == 1)
```


## What goes wrong here?

```{r eval = FALSE}
flights |> filter(month = 1)
```

![](figures/dplyr-error.png)

. . .

```{r}
flights |> filter(month == 1)
```


## {background-image="figures/dplyr-mutate.png" background-size="60%"}

:::footer
Artwork by @allison_horst
:::

## `mutate()` syntax 

<center>```DATA |> mutate(VARIABLE = EXPRESSION) ```</center>

If `VARIABLE` already exists, it modifies the column; otherwise, it will create a new one.

```{r}
flights |> mutate(gain = dep_delay - arr_delay)
```


## [You can put multiple mutations together, or separately]{.r-fit-text}

These two are identical: 

```{r echo = FALSE}
options(pillar.width= 50)
```


::::{.columns}

:::{.column}

```{r}
flights |> 
  mutate(gain = dep_delay - arr_delay, 
         speed = distance / (air_time / 60))
```

:::

:::{.column}

```{r}
flights |> 
  mutate(gain = dep_delay - arr_delay) |> 
  mutate(speed = distance / (air_time / 60))
```

:::

::::

## [We can also compare them properly :)]{.r-fit-text}

```{r}
v1 <- flights |> 
  mutate(gain = dep_delay - arr_delay, 
         speed = distance / (air_time / 60))

v2 <- flights |> 
  mutate(gain = dep_delay - arr_delay) |> 
  mutate(speed = distance / (air_time / 60))

identical(v1, v2)
```

## Something about design

By default, columns are mutated in the end of the data frame, what if you want to put them at position xxxx? How do I do something like this? 

```{r echo = FALSE}
flights |> 
  mutate(gain = dep_delay - arr_delay, .before = 1) |> 
  head()
```


. . .

Part of the reason `tidyverse` is neat is that it makes things easy. But define easy ...


. . .

You will *expect* for every main task, you don't need to do much for small tweaks.

## Your time

Read the documentation of `mutate()` and modify the following code to put the `gain` column:

```{r eval = FALSE}
flights |> 
  mutate(gain = dep_delay - arr_delay) 
```

* as the first column, 
* after the `day` variable, and 
* keep only the columns used to create the `gain` column

## Solution 

```{r eval = FALSE}
flights |> mutate(gain = dep_delay - arr_delay, .before = 1) 
flights |> mutate(gain = dep_delay - arr_delay, .after = day)
flights |> mutate(gain = dep_delay - arr_delay, .keep = "used")
```

Why these arguments have "." in front of everything?

. . .

:::{.fragment}

  * *Function developer* needs to accommodate the fact that users will do all sorts of things with their functions, e.g. you may name a column `after` for the number of mins after the scheduled time
  * If `after` is also an argument name inside `mutate()`, it will then be confusing whether you are referring to the column or the argument.
  * Prefixing the argument name with `.` avoids this problem -- **it's a good practice**.

I don't say you should prefix all your variables with `.`, but package developers should do that for good practice.

:::


# Sorry, Allison Horst doesn't have art illustration for  `group_by()` and `summarize()`


## [`group_by()` and `summarize()` syntax]{.r-fit-text}

<center>```DATA |> group_by(VARIABLEs) |> summarize(EXPRESSION)```</center>

Example:

```{r}
flights |> group_by(month)
```

The header tells you that the data is grouped by `month` and there are 12 groups (12 months).

## [Example: `group_by()` + `summarize()`]{.r-fit-text}

::::{.columns}
:::{.column}

```{r}
flights |>
  group_by(month) |>
  summarize(avg_dep_delay = mean(dep_delay))
```
:::


:::{.column}
:::{.fragment}


I hope you remember:

```{r}
flights |>
  group_by(month) |>
  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE))
```
:::
:::

::::

## [Of course, you can do multiple summaries]{.r-fit-text}

```{r}
flights |>
  group_by(month, origin) |>
  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE),
            avg_arr_delay = mean(arr_delay, na.rm = TRUE))
```

. . . 

But the following means summarize `avg_dep_delay` first, then summarize `avg_arr_delay` from the result of the first summary, which is not what we want:

```{r eval = FALSE}
flights |>
  group_by(month, origin) |>
  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE)) |> 
  summarize(avg_arr_delay = mean(arr_delay, na.rm = TRUE))
```

## [Decompose a problem into dplyr verbs]{.r-fit-text}

**Task: We want to sumamrize the proportion of flights with departure delay larger than 2 hours.**

. . .

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  

. . .

This sounds like a `mutate()` and we learn the "larger than 2 hrs" part in `filter()`

. . .

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") 
```

## [Decompose a problem into dplyr verbs]{.r-fit-text}

**Task: We want to sumamrize the proportion of flights with departure delay larger than 2 hours.**

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  
2. Then I need to count the number of observations for over and below 2h delay.

. . .

This sounds like `group_by()` and `summarize()`, but I want what's inside `summarise()` to be the count

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") |> 
  group_by(over_2h_delay) |>
  summarise(n = n())
```

## [Decompose a problem into dplyr verbs]{.r-fit-text}

**Task: We want to sumamrize the proportion of flights with departure delay larger than 2 hours.**

Thought process:

1. I need label the rows as whether they are delay more than 2 hrs or not.  
2. Then I need to count the number of observations for over and below 2h delay.
3. Then I need to calculate proportion based on `n`.

. . .

This sounds like `mutate()` again

```{r}
flights |> 
  mutate(over_2h_delay = dep_delay > 120, .keep = "used") |> 
  group_by(over_2h_delay) |>
  summarise(n = n()) |> 
  mutate(prop = n/ sum(n) * 100)
```

## [Decompose a problem into dplyr verbs]{.r-fit-text}

::::{.columns}

:::{.column width="45%"}
Can we look at those NAs? 

```{r}
flights |> filter(is.na(dep_delay))
```


There are records with no arrival and departure time - we will need to keep them in mind about this data.
:::

:::{.column width="53%"}

Why can't you do 

<center>`filter(dep_delay == NA)`?</center>

This is not legit because comparing anything with `NA` gives an `NA` (rather than giving `FALSE`):

```{r}
1 == NA
2!= NA
```
:::
::::

## Your time

With the `mtcars` data:

1) Convert the `mpg` variable into `kpl` (1 mpg = 0.425144 km/l)
2) Only look at V-shaped engine *Hint: look at the documentation to see what this means*
3) Find the average `kpl` and `disp` for each number of cylinders
4) Arrange the result by `disp` in descending order *Hint: look through `dplyr` reference page to find what's the verb for this task*
